# 자동한도조정 엔진 - 기획서

> **Strategy Planner Deliverable**  
> **프로젝트**: NGUP 가입설계 자동한도조정  
> **문서 버전**: 1.1 | **작성일**: 2026-01-27 | **수정일**: 2026-01-27

---

## Executive Summary

**본 엔진은 가입설계 화면에서 "자동한도조정" 버튼 클릭 시, 주계약/특약/급부 간 복잡한 관계를 모두 고려하여 가입 가능한 최대 금액으로 자동 조정하는 최적화 알고리즘을 구현한다.**

| 항목         | 내용                                                                                 |
| ------------ | ------------------------------------------------------------------------------------ |
| **Problem**  | 20~30개 특약이 급부를 공유하고, 급부별 캡이 다르며, 가입단위가 달라 수동 조정 불가능 |
| **Solution** | 제약 조건 기반 최적화 알고리즘으로 모든 조건을 만족하는 최대 금액 자동 계산          |
| **Impact**   | 설계사 조정 시간 90% 감소, 초과 오류 제로, 완전판매 지원                             |

---

## 1. 데이터 모델 (ER Diagram)

```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│   Product   │ 1   N │   Rider     │ N   M │   Benefit   │
│  (주계약)    │───────│  (특약)     │───────│   (급부)     │
└─────────────┘       └─────────────┘       └─────────────┘
      │                     │                     │
      │                     │                     │
      ▼                     ▼                     ▼
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│ ProductLimit│       │ RiderLimit  │       │ BenefitCap  │
│ (상품한도)   │       │ (특약한도)   │       │  (급부캡)    │
│ - min_amt   │       │ - min_amt   │       │ - cap_type  │
│ - max_amt   │       │ - max_amt   │       │ - cap_value │
│ - unit      │       │ - unit      │       │ - priority  │
└─────────────┘       └─────────────┘       └─────────────┘
```

### 1.1 핵심 엔티티 정의

| 엔티티           | 설명           | 주요 속성                                 |
| ---------------- | -------------- | ----------------------------------------- |
| **Product**      | 주계약         | product_id, name, base_amount             |
| **Rider**        | 특약           | rider_id, name, current_amount, unit      |
| **Benefit**      | 급부           | benefit_id, name, description             |
| **RiderBenefit** | 특약-급부 연결 | rider_id, benefit_id, contribution_ratio  |
| **BenefitCap**   | 급부 한도      | benefit_id, cap_type, cap_value, priority |

### 1.2 관계 정의

```
Product 1 ────► N Rider (주계약 1개에 특약 N개)
Rider   N ◄───► M Benefit (특약과 급부는 N:M 관계)
Benefit 1 ────► N BenefitCap (급부는 여러 한도 보유)
```

---

## 2. 제약 조건 (Constraints)

### 2.1 특약 레벨 제약

```
C1: Rider_Min ≤ Rider_Amount ≤ Rider_Max
    - 각 특약의 가입금액은 최소~최대 범위 내

C2: Rider_Amount % Unit = 0
    - 가입금액은 가입단위의 배수
```

### 2.2 급부 레벨 제약

```
C3: SUM(Rider_Amount * Contribution_Ratio) ≤ Benefit_Cap
    - 해당 급부에 속한 모든 특약 금액의 합이 급부 캡 이하

C4: 다중 캡 적용 시 Priority 순서대로 검증
    - cap_type: 'absolute', 'relative', 'cumulative'
```

### 2.3 상품 레벨 제약

```
C5: Total_Premium ≤ Budget (optional)
    - 총 보험료가 예산 이하 (선택적)

C6: 필수 특약은 0보다 커야 함
    - is_mandatory = true인 특약은 최소값 이상
```

---

## 3. 자동조정 알고리즘

### 3.1 알고리즘 전략 (Multi-Algorithm Strategy)

**v1.2 업데이트**: 상황에 따라 적합한 최적화 전략을 선택할 수 있도록 3가지 알고리즘을 제공한다.

> [!NOTE]
> 기본값은 **비례 감액 (Proportional)** 이며, 사용자가 UI에서 즉시 변경하여 결과를 비교할 수 있다.

#### 전략 1: 비례 감액 (Proportional Reduction) - Default

- **원칙**: 현재 설계된 특약 간의 **금액 비율(Weight)** 을 유지하며 초과분을 균등 분배.
- **장점**: 설계사의 의도(비율)를 가장 잘 보존함.
- **단점**: 모든 특약이 조금씩 깎임.

#### 전략 2: 효율순 감액 (Greedy Global Optimized) - v1.4 Final

- **원칙**: **전역 최적화(Global Optimization)**. 단일 급부 위반이 아닌, 전체 급부의 위반 현황을 종합적으로 판단.
- **우선순위($S$)**: **$S = (V \times 10^{10}) + (E \times 10^5) + A_{curr}$**
  1. **$V$ (Violation Count)**: 몇 개의 급부 한도를 동시에 위반 중인가? (다중 위반 해결 최우선)
  2. **$E$ (Efficiency)**: 1 Unit 감액 시 해소되는 초과액의 총합 (효율 중심)
  3. **$A$ (Amount)**: 가입금액이 큰 특약 (보조 기준)
- **성능 최적화**:
  - **Batch Reduction**: 1단위씩 깎지 않고, 위반액(Excess)만큼 한 번에 과감하게 감액.
  - **Priority Queue**: 매번 정렬하지 않고 힙(Heap) 사용하여 속도 극대화.
- **장점**: 다중 급부가 얽힌 복잡한 상황에서도 최소 횟수의 조정으로 문제를 해결함.

#### 전략 3: 역순 감액 (LIFO - Last In First Out)

- **원칙**: **나중에 추가된 특약** (리스트의 뒤쪽)부터 감액.
- **장점**: 기존에 입력해둔 특약들은 보존하고, 방금 추가해서 문제를 일으킨 특약만 조정.
- **단점**: 특약 추가 순서에 의존적임.

#### 공통 처리 로직

1. **가입단위 정합성**: 모든 감액은 특약별 `unit` 단위로 내림(Floor) 또는 올림(Ceil) 처리하여 `mod unit == 0` 유지.
2. **최소값 보호**: `min_amount` 이하로는 절대 감액하지 않음.
3. **불가능 시 알림**: 어떤 전략으로도 해결 안 되면 경고.

#### 예시 비교 (초과분 1,000만원 발생 시)

- **비례**: 암 600만, 뇌 300만, 심장 100만씩 골고루 감액
- **효율순**: 단위가 작아 세밀한 조정이 가능한 특약 or 여유분이 많은 특약 우선
- **역순**: 심장(가장 나중에 추가됨)에서만 1,000만 감액

### 3.2 Pseudo-code

```python
def auto_adjust_limits(riders, benefits, caps):
    """
    자동한도조정 알고리즘

    Args:
        riders: List[Rider] - 특약 목록 (현재 금액, 최소/최대, 단위 포함)
        benefits: List[Benefit] - 급부 목록
        caps: Dict[benefit_id, List[Cap]] - 급부별 캡 목록

    Returns:
        Dict[rider_id, adjusted_amount] - 조정된 금액
    """

    # Step 1: 현재 가입금액 유지 (최대값 초기화 하지 않음)
    # 사용자가 설정한 금액을 보존하면서 초과분만 감액
    # (maximize=True 옵션 시에만 최대값 초기화)

    # Step 2: 제약 만족할 때까지 반복
    max_iterations = 100
    for iteration in range(max_iterations):

        violation = find_first_violation(riders, benefits, caps)

        if violation is None:
            break  # 모든 제약 만족

        # Step 3: 위반된 급부 처리
        benefit_id, excess_amount = violation

        # 해당 급부에 연결된 특약들
        linked_riders = get_riders_by_benefit(benefit_id)

        # 우선순위: 금액 큰 순 → 비필수 → 가입단위 큰 순
        linked_riders.sort(key=lambda r: (
            -r.amount,
            r.is_mandatory,
            -r.unit
        ))

        # Step 4: 감액
        remaining_excess = excess_amount
        for rider in linked_riders:
            if remaining_excess <= 0:
                break

            # 감액 가능한 양 계산
            reducible = rider.amount - rider.min_amount
            reduce_amount = min(reducible, remaining_excess)

            # 가입단위에 맞게 내림
            reduce_amount = (reduce_amount // rider.unit) * rider.unit

            rider.amount -= reduce_amount
            remaining_excess -= reduce_amount

    # Step 5: 결과 반환
    return {r.rider_id: r.amount for r in riders}


def find_first_violation(riders, benefits, caps):
    """
    첫 번째 제약 위반 탐지
    """
    # 알고리즘 전략별 위반 탐지 및 감액 대상 선정 로직
    # - [비례 감액]:
    #   1. 전체 위반 급부 스캔 (Detection)
    #   2. 위반 급부에 기여하는 특약들을 비율에 따라 감액
    # - [Global Greedy]:
    #  1. 전체 위반 급부 스캔 (Detection)
    #  2. 특약별 점수 산정: $S = V \cdot 10^{10} + E \cdot 10^5 + A$
    #  3. 최적 특약 선정 및 **배치 감액 (Batch Reduction)**
    #  4. 증분 업데이트 (Incremental Update)
    # - [역순]: 리스트 뒤쪽(최신)부터 삭감
    for benefit in benefits:
        # 해당 급부에 기여하는 금액 합산
        total_contribution = 0
        for rider in get_riders_by_benefit(benefit.id):
            ratio = get_contribution_ratio(rider.id, benefit.id)
            total_contribution += rider.amount * ratio

        # 급부 캡과 비교
        for cap in caps[benefit.id]:
            if total_contribution > cap.value:
                excess = total_contribution - cap.value
                return (benefit.id, excess)

    return None  # 위반 없음
```

### 3.3 시간 복잡도

- **Best Case**: O(R × B) - 초기화 후 위반 없음
- **Worst Case**: O(I × R × B × C) - I: 반복 횟수, R: 특약 수, B: 급부 수, C: 캡 수
- **실제 예상**: 특약 30개, 급부 50개 기준 < 100ms

---

## 4. 조정 우선순위 정책

### 4.1 감액 우선순위 (높은 것부터 감액)

| 순위 | 기준             | 설명 (Global Optimization)                      |
| ---- | ---------------- | ----------------------------------------------- |
| 1    | **잠금(Lock)**   | 사용자 잠금 제외                                |
| 2    | **위반 수($V$)** | 동시에 여러 급부 위반 시 최우선 처방            |
| 3    | **효율($E$)**    | 단위 감액 당 해소 효과 극대화                   |
| 4    | **금액($A$)**    | 동점 시 금액 큰 특약 우선                       |
| 5    | **배치 처리**    | 1 Unit이 아닌 필요한 만큼($Excess$) 한번에 감액 |

### 4.2 증액 우선순위 (여력이 있을 때)

| 순위 | 기준                  | 근거          |
| ---- | --------------------- | ------------- |
| 1    | 필수 특약             | 완전판매 준수 |
| 2    | 고객 선호 특약        | 니즈 반영     |
| 3    | 보험료 효율 높은 특약 | 가성비        |

---

## 5. Edge Cases

### 5.1 감액 불가능 케이스

```
상황: 모든 특약이 최소값인데도 급부 초과
처리:
  - 가장 우선순위 낮은 특약을 0원으로 (삭제)
  - 삭제 불가 시 에러 반환
  - 에러 코드: ERR_UNSOLVABLE_CONSTRAINT
```

### 5.2 순환 의존성

```
상황: 특약 A 감액 → 특약 B 영향 → 특약 A 영향
처리:
  - 최대 100회 반복 후 수렴 안되면 에러
  - 에러 코드: ERR_CIRCULAR_DEPENDENCY
```

### 5.3 가입단위 불일치

```
상황: 특약 A 단위 100만원, 특약 B 단위 50만원, 같은 급부
처리:
  - 최소공배수(LCM) 기준으로 조정
  - 또는 세밀한 단위 우선 조정
```

---

## 6. 데이터 예시

### 6.1 샘플 특약 구조

```json
{
  "riders": [
    {
      "rider_id": "R001",
      "name": "암진단특약",
      "current_amount": 50000000,
      "min_amount": 10000000,
      "max_amount": 100000000,
      "unit": 10000000,
      "benefits": ["B001", "B002"]
    },
    {
      "rider_id": "R002",
      "name": "뇌출혈진단특약",
      "current_amount": 30000000,
      "min_amount": 5000000,
      "max_amount": 50000000,
      "unit": 5000000,
      "benefits": ["B001", "B003"]
    },
    {
      "rider_id": "R003",
      "name": "급성심근경색특약",
      "current_amount": 30000000,
      "min_amount": 5000000,
      "max_amount": 50000000,
      "unit": 5000000,
      "benefits": ["B001", "B004"]
    }
  ],
  "benefits": [
    {
      "benefit_id": "B001",
      "name": "CI 급부",
      "cap": 100000000
    },
    {
      "benefit_id": "B002",
      "name": "암 급부",
      "cap": 80000000
    }
  ]
}
```

### 6.2 조정 시나리오

```
[Before]
암진단특약:     5,000만원 (암급부 5천만, CI급부 5천만 기여)
뇌출혈진단특약: 3,000만원 (CI급부 3천만 기여)
급성심근경색:   3,000만원 (CI급부 3천만 기여)

CI 급부 합계: 5천만 + 3천만 + 3천만 = 1.1억 → 1억 캡 초과!

[자동한도조정]
1. CI 급부 초과 감지: 1,000만원 초과
2. 감액 대상 선정: 암진단특약 (금액 최대)
3. 암진단특약 5,000만 → 4,000만 감액

[After]
암진단특약:     4,000만원 (효율이 좋거나 금액이 커서 선정됨)
뇌출혈진단특약: 3,000만원
급성심근경색:   3,000만원

CI 급부 합계: 4천만 + 3천만 + 3천만 = 1억 (캡 이내 ✓)
```

---

## 7. Developer Handoff

### 7.1 기술적 고려사항 (Technical Considerations) - v1.4 Update

#### 7.1.1 성능 최적화 (Performance Optimization)

- **증분 업데이트 (Incremental Update)**: 매 루프마다 전체 급부 합계를 재계산하지 않고, 변경된 차액만 반영하여 $O(N)$ 연산을 $O(1)$에 가깝게 단축.
- **우선순위 큐 (Priority Queue)**: 매번 정렬($O(N \log N)$)하는 대신 Heap($O(\log N)$)을 사용하여 대규모 데이터 처리 속도 보장.
- **배치 처리 (Batch Reduction)**: 루프 횟수를 줄이기 위해 미세 조정(1 Unit) 대신 필요한 만큼(Target) 한 번에 감액.

#### 7.1.2 데이터 무결성

- **단위 보정**: 배치 처리 시에도 반드시 가입단위(Unit) 배수로 올림(Ceil) 처리하여 상품 규칙 준수.
- **최소값 보호**: 감액 시 Min Amount 이하로 내려가지 않도록 Clamp 처리.

### 7.2 함수 시그니처

```python
def auto_adjust_limits(
    riders: List[RiderInput],
    benefits: List[BenefitInput],
    caps: Dict[str, List[CapInput]],
    options: AdjustOptions = None
) -> AdjustResult:
    """
    자동한도조정 엔진 메인 함수

    Returns:
        AdjustResult:
            - adjusted_riders: Dict[rider_id, new_amount]
            - violations_fixed: int
            - total_reduction: int
            - warnings: List[str]
    """
```

### 7.3 에러 코드

| 코드               | 메시지                 | 발생 조건            |
| ------------------ | ---------------------- | -------------------- |
| `ERR_UNSOLVABLE`   | 조정 불가능한 제약     | 최소값으로도 초과    |
| `ERR_CIRCULAR`     | 순환 의존성 감지       | 100회 반복 후 미수렴 |
| `ERR_INVALID_UNIT` | 유효하지 않은 가입단위 | unit <= 0            |
| `ERR_NO_RIDERS`    | 특약 없음              | 빈 입력              |

### 7.4 UI 요구사항 (for UX/UI Architect)

| 요소                | 설명                                      |
| ------------------- | ----------------------------------------- |
| **알고리즘 토글**   | [⚖️ 비례] [💰 금액순] [↩️ 역순] 선택 버튼 |
| **조정 전/후 비교** | 변경된 특약 하이라이트                    |
| **금액 변화 표시**  | ▼ 감액, ▲ 증액 화살표                     |
| **급부 상태 표시**  | 캡 대비 % 프로그레스 바                   |
| **워닝 표시**       | 삭제된 특약, 최소값 도달 알림             |

---

## 8. 검증 계획

### 8.1 테스트 케이스

| TC-ID  | 시나리오                  | 예상 결과             |
| ------ | ------------------------- | --------------------- |
| TC-001 | 단일 특약, 단일 급부 초과 | 감액 성공             |
| TC-002 | 다수 특약, 단일 급부 공유 | 우선순위대로 감액     |
| TC-003 | 단일 특약, 다중 급부      | 모든 급부 캡 만족     |
| TC-004 | 최소값까지 감액           | 경고 + 추가 감액 불가 |
| TC-005 | 조정 불필요 (모두 정상)   | 변경 없음             |
| TC-006 | 가입단위 다른 특약들      | 단위 맞춰 조정        |

---

**문서 끝 - Strategy Planner 산출물**
